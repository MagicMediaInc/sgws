<?php


/**
 * Skeleton subclass for performing query and update operations on the 'subtipo_user' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.1 on:
 *
 * 06/02/2013 06:05:51
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model.sgws
 */
class SubtipoUserPeer extends BaseSubtipoUserPeer {
    
    public static function getListParentTypeCadastroCliente($tipoCadastro) {
        $c =  new Criteria();
        $c->add(self::ID_TIPO_CADASTRO, $tipoCadastro, Criteria::EQUAL);
        $c->add(self::ID_PARENT, '0', Criteria::EQUAL);
        return self::doSelect($c);
    }
    
    
    public static function getDataByCodigoVelhio($id)
    {
        $c = new Criteria();
        $c->add(self::ID_VELHIO, $id, Criteria::EQUAL);
        return self::doSelectOne($c);
    }
    
    public static function displaySubTipos($id_padre, $id_tipo_cadastro)
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);
        $c->addSelectColumn(self::SUBTIPO);
        $c->addSelectColumn(self::POSITION);
        $c->add(self::ID_TIPO_CADASTRO,$id_tipo_cadastro, Criteria::EQUAL);
        
        $c->add(self::ID_PARENT,$id_padre, Criteria::EQUAL);
        
        $c->addAscendingOrderByColumn(self::POSITION);
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo            
        while($res = $rs->fetch())
        {
            $datoSeccion['id'] = $res['ID_SUBTIPO'];
            $datoSeccion['subtipo'] = $res['SUBTIPO'];
            $datoSeccion['position'] = $res['POSITION'];
            $datos[] = $datoSeccion;
        }            
        if (!empty($datos)){
                return $datos;
        }else{
                return false;
        }
    }
    
    public static function getSubTiposByParente($id_padre)
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);
        $c->addSelectColumn(self::SUBTIPO);
        $c->addSelectColumn(self::POSITION);
        
        $c->add(self::ID_PARENT,$id_padre, Criteria::EQUAL);
        
        $c->addAscendingOrderByColumn(self::POSITION);
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo            
        while($res = $rs->fetch())
        {
            $datoSeccion['id'] = $res['ID_SUBTIPO'];
            $datoSeccion['nome'] = $res['SUBTIPO'];
            $datoSeccion['position'] = $res['POSITION'];
            $datos[] = $datoSeccion;
        }            
        if (!empty($datos)){
                return $datos;
        }else{
                return false;
        }
    }
    
    public static function getSubTiposFornecedor($id)
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);
        $c->addSelectColumn(self::SUBTIPO);
        $c->addSelectColumn(self::POSITION);
        
        $c->add(self::ID_PARENT,0, Criteria::NOT_EQUAL);
        $c->add(self::ID_TIPO_CADASTRO,$id, Criteria::EQUAL);
        
        
        $c->addAscendingOrderByColumn(self::POSITION);
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo            
        while($res = $rs->fetch())
        {
            $datoSeccion['id'] = $res['ID_SUBTIPO'];
            $datoSeccion['nome'] = $res['SUBTIPO'];
            $datoSeccion['position'] = $res['POSITION'];
            $datos[] = $datoSeccion;
        }            
        if (!empty($datos)){
                return $datos;
        }else{
                return false;
        }
    }
    
    public static function displayListSubTipos($id_tipo_cadastro = "")
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);
        $c->addSelectColumn(self::SUBTIPO);
        $c->addSelectColumn(self::POSITION);
        $c->add(self::ID_PARENT,0,Criteria::EQUAL);
        if($id_tipo_cadastro)
        {
            $c->add(self::ID_TIPO_CADASTRO,$id_tipo_cadastro, Criteria::EQUAL);
        }
        $c->addAscendingOrderByColumn(self::POSITION);
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo            
        while($res = $rs->fetch())
        {
            $datoSeccion['id'] = $res['ID_SUBTIPO'];
            $datoSeccion['subtipo'] = $res['SUBTIPO'];
            $datoSeccion['position'] = $res['POSITION'];
            $datos[] = $datoSeccion;
        }            
        if (!empty($datos)){
                return $datos;
        }else{
                return false;
        }
    }
    
    
    public static function countSubTipos($idSubTipo)
    {
        $c = new Criteria();
        $c->add(self::ID_PARENT,$idSubTipo,Criteria::EQUAL);
        $c->addAscendingOrderByColumn(self::POSITION);
        return self::doCount($c);
    }
    
    public static function getPorcentajeSubTipo($idSubTipo)
    {
        $c = new Criteria();
        $c->add(self::ID_SUBTIPO,$idSubTipo,Criteria::EQUAL);
        
        return self::doSelectOne($c);
    }
    
    /**
     * Busca los subtipos padres
     *
     * @global <integer> $sections Al momento de generar la funcion recursiva se deben almacenar todos los valores en un mismo array
     * @param <inetegr> $id_subtipo
     * @return <array>
     */
    public static function findSubTiposPaterns($id_subtipo="")
    {
        global $sections;
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);        
        $c->addSelectColumn(self::SUBTIPO);        
        //Filtros
        $c->add(self::ID_PARENT,0,Criteria::EQUAL);
        if($id_subtipo)
        {
            $c->add(self::ID, $id_subtipo, Criteria::NOT_EQUAL);
        }
        $c->addAscendingOrderByColumn(self::POSITION);
        //Ejecucion de consulta
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        $sections[0] = 'None';
        while($res = $rs->fetch())
        {
            $sections[$res['ID_SUBTIPO']] = "&bull;&nbsp;".$res['SUBTIPO'];
            self::findSubTiposChildren($res['ID_SUBTIPO'],"&nbsp;",$id_subtipo);
        }
        if(!empty($sections)){
            return $sections;
        }else{
            return false;
        }            
    }
    /**
     * Busca los subtipos padres
     *
     * @global <integer> $sections Al momento de generar la funcion recursiva se deben almacenar todos los valores en un mismo array
     * @param <ineteger> $id_tc
     * @return <array>
     */
    public static function findSubTiposByTC($id_tc, $id_sub_tipo = '')
    {
        global $sections;
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);        
        $c->addSelectColumn(self::SUBTIPO);        
        //Filtros
        $c->add(self::ID_PARENT,0,Criteria::EQUAL);
        $c->add(self::ID_TIPO_CADASTRO, $id_tc, Criteria::EQUAL);
        if($id_sub_tipo)
        {
            $c->add(self::ID_SUBTIPO, $id_sub_tipo, Criteria::NOT_EQUAL);
        }
        
        $c->addAscendingOrderByColumn(self::POSITION);
        //Ejecucion de consulta
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        $sections[0] = 'None';
        while($res = $rs->fetch())
        {
            $sections[$res['ID_SUBTIPO']] = "&bull;&nbsp;".$res['SUBTIPO'];
            self::findSubTiposChildByTc($res['ID_SUBTIPO'],"&nbsp;",$id_tc, $id_sub_tipo);
        }
        if(!empty($sections)){
            return $sections;
        }else{
            return false;
        }            
    }
    
    
    public static function listSubTiposPaiByTC($id_tc, $id_pai = 0)
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);        
        $c->addSelectColumn(self::SUBTIPO);        
        //Filtros
        $c->add(self::ID_PARENT,$id_pai,Criteria::EQUAL);
        $c->add(self::ID_TIPO_CADASTRO, $id_tc, Criteria::EQUAL);
        $c->addAscendingOrderByColumn(self::POSITION);
        //Ejecucion de consulta
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        while($res = $rs->fetch())
        {
            $dato['id_subtipo'] = $res['ID_SUBTIPO'];            
            $dato['subtipo'] = $res['SUBTIPO'];            
            $datos[] = $dato;
        }
        if(!empty($datos)){
            return $datos;
        }else{
            return false;
        }            
    }
    
    /**
     * Funcion que busca secciones hijas
     * 
     * @global <integer> $sections Al momento de generar la funcion recursiva se deben almacenar todos los valores en un mismo array
     * @param <integer> $id_padre
     * @param <string> $tab        Es el separado jerarquico de los nodos
     * @param <integer> $subtipo_edit Es la actual seccion que se esta editando. Se usa para excluir del array la seccion seleccionada
     * @return <array>
     */
    public static function findSubTiposChildren($id_padre=0,$tab="",$subtipo_edit)
    {
        global $sections;
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);
        $c->addSelectColumn(self::SUBTIPO);
        //Filtros
        $c->add(self::ID_PARENT,$id_padre,Criteria::EQUAL);
        $c->add(self::ID_SUBTIPO ,$subtipo_edit,Criteria::NOT_EQUAL);
        $c->addAscendingOrderByColumn(self::POSITION);
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        $tab.="&nbsp;&nbsp;&nbsp;&nbsp;";
        if ($rs->rowCount()>0){
            while($res = $rs->fetch())
            {
                $sections[$res['ID_SUBTIPO']] = $tab."-&nbsp;".$res['SUBTIPO'];
                self::findSubTiposChildren($res['ID_SUBTIPO'],$tab,$subtipo_edit);
            }
            return $sections;
        }
    }
    /**
     * Funcion que busca secciones hijas
     * 
     * @global <integer> $sections Al momento de generar la funcion recursiva se deben almacenar todos los valores en un mismo array
     * @param <integer> $id_padre
     * @param <string> $tab        Es el separado jerarquico de los nodos
     * @param <integer> $subtipo_edit Es la actual seccion que se esta editando. Se usa para excluir del array la seccion seleccionada
     * @return <array>
     */
    public static function findSubTiposChildByTc($id_padre=0,$tab="",$id_tc, $id_sub_tipo = '')
    {
        global $sections;
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);
        $c->addSelectColumn(self::SUBTIPO);
        //Filtros
        $c->add(self::ID_PARENT,$id_padre,Criteria::EQUAL);
        $c->add(self::ID_TIPO_CADASTRO ,$id_tc,Criteria::EQUAL);
        if($id_sub_tipo)
        {
            $c->add(self::ID_SUBTIPO, $id_sub_tipo, Criteria::NOT_EQUAL);
        }
        $c->addAscendingOrderByColumn(self::POSITION);
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        $tab.="&nbsp;&nbsp;&nbsp;&nbsp;";
        if ($rs->rowCount()>0){
            while($res = $rs->fetch())
            {
                $sections[$res['ID_SUBTIPO']] = $tab."-&nbsp;".$res['SUBTIPO'];
                self::findSubTiposChildByTc($res['ID_SUBTIPO'],$tab,$id_tc);
            }
            return $sections;
        }
    }
    
    public static function findSubTiposChildrenEdit($id_padre=0)
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);
        $c->addSelectColumn(self::SUBTIPO);
        $c->addSelectColumn(self::POSITION);
        //Filtros
        $c->add(self::ID_PARENT,$id_padre,Criteria::EQUAL);
        //$c->add(self::ID_SUBTIPO ,$subtipo_edit,Criteria::NOT_EQUAL);
        $c->addAscendingOrderByColumn(self::POSITION);
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        
        while($res = $rs->fetch())
        {
            $datoSeccion['id'] = $res['ID_SUBTIPO'];
            $datoSeccion['subtipo'] = $res['SUBTIPO'];
            $datoSeccion['position'] = $res['POSITION'];
            $datos[] = $datoSeccion;                
        }
        return $datos;
        
    }

    public static function positionSubTipo($id_subtipo)
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::POSITION);
        //Filtros
        $c->add(self::ID_SUBTIPO,$id_subtipo, Criteria::EQUAL);
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        while($res = $rs->fetch())
        {
            $datoSeccion['posicion'] = $res['POSITION'];
        }
        if (!empty($datoSeccion)){
                return $datoSeccion;
        }else{
                return false;
        }
    }
    
    public static function updatePosition($newPosition,$paren_id,$beforePosition)
    {
        $con = Propel::getConnection();
        // select from�
        $c1 = new Criteria();
        $c1->add(self::ID_PARENT, $paren_id);
        $c1->add(self::POSITION, $beforePosition);
        // update set
        $c2 = new Criteria();
        $c2->add(self::POSITION, $newPosition);
        BasePeer::doUpdate($c1, $c2, $con);
    }
    
    public static function updatePrincipalPosition($position,$id_subtipo)
    {
            $con = Propel::getConnection();
            // select from�
            $c1 = new Criteria();
            $c1->add(self::ID_SUBTIPO, $id_subtipo);
            // update set
            $c2 = new Criteria();
            $c2->add(self::POSITION, $position);
            BasePeer::doUpdate($c1, $c2, $con);
    }
    
    public static function updatePaternSubTipo($paternNew,$id_subtipo)
    {
            $con = Propel::getConnection();
            // select from�
            $c1 = new Criteria();
            $c1->add(self::ID_SUBTIPO, $id_subtipo);
            // update set
            $c2 = new Criteria();
            $c2->add(self::ID_PARENT, $paternNew);
            $c2->add(self::POSITION, 1);
            BasePeer::doUpdate($c1, $c2, $con);
    }
    
    public static function subTiposNext($parentId,$actualPosition)
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);
        $c->addSelectColumn(self::POSITION);
        //Filtros
        $c->add(self::ID_PARENT,$parentId, Criteria::EQUAL);
        $c->add(self::POSITION,$actualPosition, Criteria::GREATER_THAN);
        $c->addAscendingOrderByColumn(self::POSITION);            
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        while($res = $rs->fetch())
        {
            $datoSeccion['id'] = $res['ID_SUBTIPO'];
            $datoSeccion['posicion'] = $res['POSITION'];
            $datos[] = $datoSeccion;
        }
        if (!empty($datos)){
            return $datos;
        }else{
            return false;
        }

    }
    
    public static function updatePaternSubTipoPosition($newPatern,$position,$id_subtipo)
    {
            $con = Propel::getConnection();
            // select from�
            $c1 = new Criteria();
            $c1->add(self::ID_SUBTIPO, $id_subtipo);
            // update set
            $c2 = new Criteria();
            $c2->add(self::ID_PARENT, $newPatern);
            $c2->add(self::POSITION, $position);
            BasePeer::doUpdate($c1, $c2, $con);
    }
    
    public static function checkExistPaterns($idPatern)
    {
            $c = new Criteria();
            //Eliminamos la columnas de seleccion en caso de que esten definidas
            $c->clearSelectColumns();
            //Se Agregan las Columnas necesarias
            $c->addSelectColumn(self::ID_SUBTIPO);
            $c->addSelectColumn(self::ID_PARENT);
            $c->addSelectColumn(self::POSITION);
            //Filtros
            $c->add(self::ID_PARENT,$idPatern, Criteria::EQUAL);
            $c->addAscendingOrderByColumn(self::POSITION);            
            $rs = self::doSelectStmt($c);
            //Se recuperan los registros y se genera arreglo
            while($res = $rs->fetch())
            {
                $datoSeccion['id'] = $res['ID_SUBTIPO'];
                $datoSeccion['id_padre'] = $res['ID_PARENT'];
                $datoSeccion['posicion'] = $res['POSITION'];
                $datos[] = $datoSeccion;
            }
            if (!empty($datos)){
                    return $datos;
            }else{
                    return false;
            }
    }
    
    public static function identifiesPosition($idParent)
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_SUBTIPO);
        $c->addSelectColumn(self::POSITION);
        //Filtros
        $c->add(self::ID_PARENT,$idParent, Criteria::EQUAL);
        $c->addDescendingOrderByColumn(self::POSITION);
        $c->setLimit(1);
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        while($res = $rs->fetch())
        {
                $datoSeccion['id'] = $res['ID_SUBTIPO'];
                $datoSeccion['position'] = $res['POSITION'];
        }
        if (!empty($datoSeccion)){
                return $datoSeccion;
        }else{
                return false;
        }
    }
    
    public static function getTipoUserVinculado($id)
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::PERMALINK);
        //Filtros
        $c->add(self::ID_SUBTIPO,$id, Criteria::EQUAL);
        
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        while($res = $rs->fetch())
        {
            $dato['valor'] = $res['PERMALINK'];
        }
        if (!empty($dato)){
            return $dato['valor'];
        }else{
            return '';
        }
    }
    
    public static function getSubTiposByTipoCadastro($id) 
    {
        $c = new Criteria();
        $c->addAscendingOrderByColumn(self::SUBTIPO);
        $c->add(self::ID_TIPO_CADASTRO, $id, Criteria::EQUAL);
        return self::doSelect($c);
    }
    
    
    public static function getTiposTipoCadastro($id = 0, $parent = 0) 
    {
        $c = new Criteria();
        $c->addAscendingOrderByColumn(self::ID_SUBTIPO);
        $c->add(self::ID_PARENT, $parent, Criteria::EQUAL);
        if($id)
        {
            $c->add(self::ID_TIPO_CADASTRO, $id, Criteria::EQUAL);
        }
        
        return self::doSelect($c);
    }

} // SubtipoUserPeer
