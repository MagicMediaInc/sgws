<?php


/**
 * Skeleton subclass for performing query and update operations on the 'vinculo_user_subtipo' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.1 on:
 *
 * 12/06/2013 17:26:11
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model.imoveis
 */
class VinculoUserSubtipoPeer extends BaseVinculoUserSubtipoPeer {
    
    
    
    public static function getSubTipoByUser($id) 
    {
        $c = new Criteria();
        $c->add(self::ID_USER, $id, Criteria::EQUAL);
        return self::doSelectOne($c);
    }
    public static function getUsuariosBySubTipo($id) 
    {
        $valida = new lynxValida();
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID_USER);
        $c->add(self::ID_SUBTIPO,$id, Criteria::EQUAL);
        
        $c->addJoin(self::ID_USER, LxUserPeer::ID_USER, Criteria::LEFT_JOIN);
        //Ejecucion de consulta
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo        
        while($res = $rs->fetch())
        {
            $dato['id_user'] = $res['ID_USER'];
            $datausuario = $valida->datosTipoUsuario($res['ID_USER']);
            $dato['nome'] = $datausuario['nome'];
            $datos[] = $dato;
        }
        if(!empty($datos)){
            return $datos;
        }else{
            return false;
        }
    }
    
    public static function getUserTipoAndSubTipo($user, $tipo, $sub_tipo)
    {
        $c = new Criteria();
        $c->add(self::ID_USER, $user, Criteria::EQUAL);
        $c->add(self::ID_TIPO_CADASTRO, $tipo, Criteria::EQUAL);
        $c->add(self::ID_SUBTIPO, $sub_tipo, Criteria::EQUAL);
        return self::doCount($c);
    }
    
    public static function getDataSubANDTipoCadastroUser($idUser, $idSubtipo)
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(TipoCadastroPeer::TIPO_CADASTRO);
        $c->addSelectColumn(SubtipoUserPeer::SUBTIPO);
        $c->addJoin(self::ID_TIPO_CADASTRO, TipoCadastroPeer::ID_TIPO_CADASTRO, Criteria::LEFT_JOIN);
        $c->addJoin(self::ID_SUBTIPO, SubtipoUserPeer::ID_SUBTIPO, Criteria::LEFT_JOIN);
        
        $c->add(self::ID_USER, $idUser, Criteria::EQUAL);
        $c->add(self::ID_SUBTIPO, $idSubtipo, Criteria::EQUAL);
        
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo            
        while($res = $rs->fetch())
        {
            $dato['tipo_cadastro']           = $res['TIPO_CADASTRO'];            
            $dato['subtipo']                = $res['SUBTIPO'];            
        }            
        if (!empty($dato)){
            return $dato;
        }else{
            return false;
        }
    }
    
    public static function deleitaVinculoUser($id_user)
    {
        $con = Propel::getConnection();
	// select from...
	$c1 = new Criteria();
        $c1->add(self::ID_USER, $id_user, Criteria::EQUAL);
	// delete
        BasePeer::doDelete($c1, $con);
    }
    
    public static function checkSubTipoByUser($idUser, $idSubtipo)
    {
        $c = new Criteria();
        $c->add(self::ID_USER, $idUser, Criteria::EQUAL);
        $c->add(self::ID_SUBTIPO, $idSubtipo, Criteria::EQUAL);
        return self::doCount($c);
    }
} // VinculoUserSubtipoPeer
