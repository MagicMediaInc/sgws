<?php


/**
 * Skeleton subclass for performing query and update operations on the 'sf_section' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.1 on:
 *
 * Thu Apr  8 16:08:35 2010
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model.section
 */
class SfSectionPeer extends BaseSfSectionPeer {
    /**
     * Funcion que desactiva todas las secciones como principal en el home
     *
     */
    public static function desactivateSectionHome()
    {
            $con = Propel::getConnection();
            // select from...
            $c1 = new Criteria();
            $c1->add(self::HOME,1, Criteria::EQUAL);

            // update set
            $c2 = new Criteria();
            $c2->add(self::HOME, 0);

            BasePeer::doUpdate($c1, $c2, $con);
    }
    /**
     * Funcion que detecta si existe un switche_menu igual al ingresado
     *
     * @param string $switche
     * @return integer
     */
    public static function checkSwitcheMenu($switche)
    {
            $c = new Criteria();
            $c->add(self::SW_MENU, $switche, Criteria::EQUAL);
            return self::doCount($c);
    }

    public static function validateSwitcheMenuUpdate($switche,$id_seccion)
    {
            $c = new Criteria();
            $c->add(self::SW_MENU, $switche, Criteria::EQUAL);
            $c->add(self::ID, $id_seccion, Criteria::NOT_EQUAL);
            return self::doCount($c);
    }

    public static function getSecciones()
    {
            $c = new Criteria();
            $c->addJoin(self::ID, SfSeccionI18nPeer::ID, Criteria::INNER_JOIN);

            $c->add(SfSeccionI18nPeer::CULTURE, 'es',Criteria::EQUAL);
            return SfSeccionI18nPeer::doSelectJoinSfSeccion($c);
    }

    public static function identifiesPosition($idParent)
    {
            $c = new Criteria();
            //Eliminamos la columnas de seleccion en caso de que esten definidas
            $c->clearSelectColumns();
            //Se Agregan las Columnas necesarias
            $c->addSelectColumn(self::ID);
            $c->addSelectColumn(self::POSITION);
            //Filtros
            $c->add(self::ID_PARENT,$idParent, Criteria::EQUAL);
            $c->addDescendingOrderByColumn(self::POSITION);
            $c->setLimit(1);
            $rs = self::doSelectStmt($c);
            //Se recuperan los registros y se genera arreglo
            while($res = $rs->fetch())
            {
                    $datoSeccion['id'] = $res['ID'];
                    $datoSeccion['position'] = $res['POSITION'];
            }
            if (!empty($datoSeccion)){
                    return $datoSeccion;
            }else{
                    return false;
            }
    }

    public static function countSections($idSection)
    {
            $c = new Criteria();
            $c->add(self::ID_PARENT,$idSection,Criteria::EQUAL);
            $c->addAscendingOrderByColumn(self::POSITION);
            return self::doCount($c);
    }

    public static function positionSection($id_section)
    {
            $c = new Criteria();
            //Eliminamos la columnas de seleccion en caso de que esten definidas
            $c->clearSelectColumns();
            //Se Agregan las Columnas necesarias
            $c->addSelectColumn(self::POSITION);
            //Filtros
            $c->add(self::ID,$id_section, Criteria::EQUAL);
            $rs = self::doSelectStmt($c);
            //Se recuperan los registros y se genera arreglo
            while($res = $rs->fetch())
            {
                $datoSeccion['posicion'] = $res['POSITION'];
            }
            if (!empty($datoSeccion)){
                    return $datoSeccion;
            }else{
                    return false;
            }
    }

    public static function updatePosition($newPosition,$paren_id,$beforePosition)
    {
            $con = Propel::getConnection();
            // select from�
            $c1 = new Criteria();
            $c1->add(self::ID_PARENT, $paren_id);
            $c1->add(self::POSITION, $beforePosition);
            // update set
            $c2 = new Criteria();
            $c2->add(self::POSITION, $newPosition);
            BasePeer::doUpdate($c1, $c2, $con);
    }

    public static function updatePrincipalPosition($position,$id_section)
    {
            $con = Propel::getConnection();
            // select from�
            $c1 = new Criteria();
            $c1->add(self::ID, $id_section);
            // update set
            $c2 = new Criteria();
            $c2->add(self::POSITION, $position);
            BasePeer::doUpdate($c1, $c2, $con);
    }

    public static function updatePaternSection($paternNew,$id_section)
    {
            $con = Propel::getConnection();
            // select from�
            $c1 = new Criteria();
            $c1->add(self::ID, $id_section);
            // update set
            $c2 = new Criteria();
            $c2->add(self::ID_PARENT, $paternNew);
            $c2->add(self::POSITION, 1);
            BasePeer::doUpdate($c1, $c2, $con);
    }

    public static function updatePaternSectionPosition($newPatern,$position,$id_section)
    {
            $con = Propel::getConnection();
            // select from�
            $c1 = new Criteria();
            $c1->add(self::ID, $id_section);
            // update set
            $c2 = new Criteria();
            $c2->add(self::ID_PARENT, $newPatern);
            $c2->add(self::POSITION, $position);
            BasePeer::doUpdate($c1, $c2, $con);
    }

    public static function listaSecciones()
    {
            $idioma_principal = SfCulturePeer::idiomaPrincipal();
            $c = new Criteria();
            $c->add(SfSeccionI18nPeer::CULTURE, $idioma_principal['culture'], Criteria::EQUAL);
            return SfSeccionI18nPeer::doSelectJoinSfSeccion($c);
    }

    public static function sectionsNext($parentId,$actualPosition)
    {
            $c = new Criteria();
            //Eliminamos la columnas de seleccion en caso de que esten definidas
            $c->clearSelectColumns();
            //Se Agregan las Columnas necesarias
            $c->addSelectColumn(self::ID);
            $c->addSelectColumn(self::POSITION);
            //Filtros
            $c->add(self::ID_PARENT,$parentId, Criteria::EQUAL);
            $c->add(self::POSITION,$actualPosition, Criteria::GREATER_THAN);
            $c->addAscendingOrderByColumn(self::POSITION);            
            $rs = self::doSelectStmt($c);
            //Se recuperan los registros y se genera arreglo
            while($res = $rs->fetch())
            {
                    $datoSeccion['id'] = $res['ID'];
                    $datoSeccion['posicion'] = $res['POSITION'];
                    $datos[] = 	$datoSeccion;
            }
            if (!empty($datos)){
                return $datos;
            }else{
                return false;
            }

    }

    public static function checkExistPaterns($idPatern)
    {
            $c = new Criteria();
            //Eliminamos la columnas de seleccion en caso de que esten definidas
            $c->clearSelectColumns();
            //Se Agregan las Columnas necesarias
            $c->addSelectColumn(self::ID);
            $c->addSelectColumn(self::ID_PARENT);
            $c->addSelectColumn(self::POSITION);
            //Filtros
            $c->add(self::ID_PARENT,$idPatern, Criteria::EQUAL);
            $c->addAscendingOrderByColumn(self::POSITION);            
            $rs = self::doSelectStmt($c);
            //Se recuperan los registros y se genera arreglo
            while($res = $rs->fetch())
            {
                $datoSeccion['id'] = $res['ID'];
                $datoSeccion['id_padre'] = $res['ID_PARENT'];
                $datoSeccion['posicion'] = $res['POSITION'];
                $datos[] = $datoSeccion;
            }
            if (!empty($datos)){
                    return $datos;
            }else{
                    return false;
            }
    }

    public static function actualizaPosicionesxDel($id_seccion)
    {
            $con = Propel::getConnection();
            // select from�
            $c1 = new Criteria();
            $c1->add(self::ID, $id_seccion);
            // update set
            $c2 = new Criteria();
            $c2->add(self::POSICION, self::POSICION-1);
            BasePeer::doUpdate($c1, $c2, $con);
    }

    public static function updatePositionsxDelete($idSection,$newPosition)
    {
            $con = Propel::getConnection();
            // select from�
            $c1 = new Criteria();
            $c1->add(self::ID, $idSection);
            // update set
            $c2 = new Criteria();
            $c2->add(self::POSITION, $newPosition);
            BasePeer::doUpdate($c1, $c2, $con);
    }

    public static function positionActualSection($idSection)
    {
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID);
        $c->addSelectColumn(self::POSITION);
        //Filtros
        $c->add(self::ID,$idSection, Criteria::EQUAL);
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        while($res = $rs->fetch())
        {
            $datoSection['id'] = $res['ID'];
            $datoSection['position'] = $res['POSITION'];
        }
        if (!empty($datoSection)){
                return $datoSection;
        }else{
                return false;
        }
    }

    public static function validatePaternSection($idSection)
    {
            $c = new Criteria();
            //Eliminamos la columnas de seleccion en caso de que esten definidas
            $c->clearSelectColumns();
            //Se Agregan las Columnas necesarias
            $c->addSelectColumn(self::ID_PARENT);
            //Filtros
            $c->add(self::ID,$idSection, Criteria::EQUAL);
            $rs = self::doSelectStmt($c);
            //Se recuperan los registros y se genera arreglo            
            while($res = $rs->fetch())
            {
                $datoSection['parent_id'] = $res['ID_PARENT'];
            }
            if (!empty($datoSection)){
                    return $datoSection;
            }else{
                    return false;
            }
    }

    public static function listSeccionesTab($id_padre,$culture)
    {
            $c = new Criteria();
            //Eliminamos la columnas de seleccion en caso de que esten definidas
            $c->clearSelectColumns();
            //Se Agregan las Columnas necesarias
            $c->addSelectColumn(self::ID);
            $c->addSelectColumn(self::ID_PADRE);
            $c->addSelectColumn(SfSeccionI18nPeer::NOMBRE_SECCION);
            //Join
            $c->addJoin(self::ID,SfSeccionI18nPeer::ID,Criteria::INNER_JOIN);
            //Filtros
            $c->add(self::ID_PADRE,$id_padre, Criteria::EQUAL);
            $c->add(SfSeccionI18nPeer::CULTURE,$culture, Criteria::EQUAL);
            $c->addAscendingOrderByColumn(self::POSICION);
            $num_registros = self::doCount($c);
            $rs = self::doSelectRS($c);
            //Se recuperan los registros y se genera arreglo
            $datoSeccion['totalRsult'] = $rs->getRecordCount();
            if ($datoSeccion['totalRsult']==0){
                    return false;
            }
            while ($rs->next())
            {
                    $datoSeccion['id'] = $rs->getInt(1);
                    $datoSeccion['id_padre'] = $rs->getInt(2);
                    $datoSeccion['nombre_seccion'] = $rs->getString(3);
                    $datos[] = 	$datoSeccion;
            }
            if (!empty($datos)){
                    return array($datos,$num_registros);
            }else{
                    return false;
            }
    }
    /**
     * Busca las secciones padres
     *
     * @global <integer> $sections Al momento de generar la funcion recursiva se deben almacenar todos los valores en un mismo array
     * @param <string> $culture
     * @param <inetegr> $id_section
     * @return <array>
     */
    public static function findSectionsPaterns($culture,$id_section="")
    {
        global $sections;
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID);        
        $c->addSelectColumn(SfSectionI18nPeer::NAME_SECTION);        
        //Filtros
        $c->addJoin(self::ID,SfSectionI18nPeer::ID,Criteria::INNER_JOIN);
        $c->add(self::ID_PARENT,0,Criteria::EQUAL);
        if($id_section)
        {
                $c->add(self::ID, $id_section, Criteria::NOT_EQUAL);
        }else{
                $cton1 = $c->getNewCriterion(self::STATUS, 1, Criteria::EQUAL);
                $cton2 = $c->getNewCriterion(self::STATUS, 2, Criteria::EQUAL);
                // combine them
                $cton1->addOr($cton2);
                // add to Criteria
                $c->add($cton1);
        }
        $c->add(SfSectionI18nPeer::LANGUAGE,$culture,Criteria::EQUAL);
        $c->addAscendingOrderByColumn(self::POSITION);
        //Ejecucion de consulta
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        $sections[0] = 'None';
        while($res = $rs->fetch())
        {
            $sections[$res['ID']] = "&bull;&nbsp;".$res['NAME_SECTION'];
            self::findSectionsChildren($res['ID'],$culture,"&nbsp;",$id_section);
        }
        if(!empty($sections)){
            return $sections;
        }else{
            return false;
        }            
    }
    /**
     * Busca las secciones padres para un nucleo
     *
     * @global <integer> $sections Al momento de generar la funcion recursiva se deben almacenar todos los valores en un mismo array
     * @param <string> $culture
     * @param <ineteger> $id_section
     * @param <ineteger> $id_nucleo
     * @return <array>
     */
    public static function findSectionsPaternsByNucleo($culture,$id_section="", $id_nucleo)
    {
        global $sections;
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(self::ID);        
        $c->addSelectColumn(SfSectionI18nPeer::NAME_SECTION);        
        //Filtros
        $c->addJoin(self::ID,SfSectionI18nPeer::ID,Criteria::INNER_JOIN);
        $c->add(self::ID_PARENT,0,Criteria::EQUAL);
        $c->add(self::ID_PROFILE, $id_nucleo,Criteria::EQUAL);
        if($id_section)
        {
                $c->add(self::ID, $id_section, Criteria::NOT_EQUAL);
        }else{
                $cton1 = $c->getNewCriterion(self::STATUS, 1, Criteria::EQUAL);
                $cton2 = $c->getNewCriterion(self::STATUS, 2, Criteria::EQUAL);
                // combine them
                $cton1->addOr($cton2);
                // add to Criteria
                $c->add($cton1);
        }
        $c->add(SfSectionI18nPeer::LANGUAGE,$culture,Criteria::EQUAL);
        $c->addAscendingOrderByColumn(self::POSITION);
        //Ejecucion de consulta
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        $sections[0] = 'None';
        while($res = $rs->fetch())
        {
            $sections[$res['ID']] = "&bull;&nbsp;".$res['NAME_SECTION'];
            self::findSectionsChildren($res['ID'],$culture,"&nbsp;",$id_section);
        }
        if(!empty($sections)){
            return $sections;
        }else{
            return false;
        }            
    }

    /**
     * Funcion que busca secciones hijas
     * 
     * @global <integer> $sections Al momento de generar la funcion recursiva se deben almacenar todos los valores en un mismo array
     * @param <integer> $id_padre
     * @param <string> $culture
     * @param <string> $tab        Es el separado jerarquico de los nodos
     * @param <integer> $seccion_edit Es la actual seccion que se esta editando. Se usa para excluir del array la seccion seleccionada
     * @return <array>
     */
    public static function findSectionsChildren($id_padre=0,$culture,$tab="",$seccion_edit)
    {
        global $sections;
        $c = new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Se Agregan las Columnas necesarias
        $c->addSelectColumn(SfSectionPeer::ID);
        $c->addSelectColumn(SfSectionI18nPeer::NAME_SECTION);
        //Filtros
        $c->addJoin(SfSectionPeer::ID,SfSectionI18nPeer::ID,Criteria::INNER_JOIN);
        $c->add(SfSectionPeer::ID_PARENT,$id_padre,Criteria::EQUAL);
        $c->add(SfSectionPeer::ID,$seccion_edit,Criteria::NOT_EQUAL);
        $c->add(SfSectionI18nPeer::LANGUAGE,$culture,Criteria::EQUAL);
        $c->addAscendingOrderByColumn(SfSectionPeer::POSITION);
        $rs = SfSectionI18nPeer::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        $tab.="&nbsp;&nbsp;&nbsp;&nbsp;";
        if ($rs->rowCount()>0){
            while($res = $rs->fetch())
            {
                $sections[$res['ID']] = $tab."-&nbsp;".$res['NAME_SECTION'];
                self::findSectionsChildren($res['ID'],$culture,$tab,$seccion_edit);
            }
            return $sections;
        }
    }

} // SfSectionPeer
